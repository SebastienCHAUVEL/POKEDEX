import { StatusCodes } from "http-status-codes";
import { Op, Sequelize } from "sequelize";
// Utils
import { HttpError } from "../utils/httpError.util.js";
import { getPokemonVote } from "../utils/pokemon.util.js";
// Models
import { Pokemon, User } from "../models/associations.js";

export async function getAll(req, res) {
  const pokemons = await Pokemon.findAll();

  return res.success(pokemons);
}

export async function getModal(req, res, next) {
  const { pokemonToFind } = req.params;

  // Try to get id
  const id = parseInt(pokemonToFind);

  // Change the where clause depend on params(id or name)
  let where = {};
  if (Number.isNaN(id)) {
    where.name = {
      [Op.iLike]: `%${pokemonToFind}%`, // Make case insensitive + flexible search
    };
  } else {
    where.id = id;
  }

  // Get the pokemon modal
  const pokemon = await Pokemon.findOne({
    where,
    include: {
      association: "types",
      // hide association relation(PokemonTypes)
      through: { attributes: [] },
    },
  });

  if (!pokemon) {
    return next(new HttpError("pokemon not found", StatusCodes.NOT_FOUND));
  }

  return res.success(pokemon);
}

export async function getComparedPokemon(req, res, next) {
  const { id, idToCompare } = req.params;

  if (id === idToCompare) {
    return next(
      new HttpError("Cannot compare the same pokemon", StatusCodes.BAD_REQUEST)
    );
  }

  // Get both of the pokemons
  const pokemons = await Pokemon.findAll({
    where: {
      [Op.or]: [{ id }, { id: idToCompare }],
    },
    include: {
      association: "types",
      // hide association relation(PokemonTypes)
      through: { attributes: [] },
    },
  });

  // In case we don't get both of the pokemons
  if (pokemons.length !== 2) {
    return next(new HttpError("pokemons not found", StatusCodes.NOT_FOUND));
  }

  return res.success(pokemons);
}

export async function addVote(req, res, next) {
  const { id } = req.params;

  const pokemon = await Pokemon.findByPk(id);
  const currentUser = await User.findByPk(req.userId);

  if (!pokemon) {
    return next(new HttpError("pokemon not found", StatusCodes.NOT_FOUND));
  }

  // Add the user vote for a pokemon(duplicate vote is not allowed)
  await pokemon.addVote(currentUser);

  // Get the pokemon updated with total votes
  const newPokemon = await getPokemonVote(id);

  return res.success(newPokemon);
}

export async function getVotes(req, res, next) {
  const { id } = req.params;

  const pokemon = await await getPokemonVote(id);

  if (!pokemon) {
    return next(new HttpError("pokemon not found", StatusCodes.NOT_FOUND));
  }

  return res.success(pokemon);
}

export async function getPodium(req, res, next) {
  const topPokemons = await Pokemon.findAll({
    attributes: {
      include: [
        // Count votes on pokemon
        [Sequelize.fn("COUNT", Sequelize.col("votes.id")), "votesCount"],
      ],
    },
    include: [
      {
        association: "votes",
        attributes: [], // Hide user
        through: { attributes: [] }, // Hide association relationship "votes->VotePokemons"
      },
    ],
    group: ["Pokemon.id"],
    order: [["votesCount", "DESC"]],
    // Filter voteless pokemons
    having: Sequelize.where(
      Sequelize.fn("COUNT", Sequelize.col("votes.id")),
      ">",
      0
    ),
    limit: 10,
    subQuery: false, // disable subQuery generated by sequelize for limit
  });

  res.success(topPokemons);
}
